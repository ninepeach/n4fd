package tlshs

import (
	"errors"
	"fmt"
	"math/rand"
	"net"
	"time"
)

var (
	ErrHandShake = errors.New("handshake failed")
)

type ServerHandshake struct {
	Conn         net.Conn
	State        uint8
	CipherSuites []uint16
	TLSVersion   uint16
}

// only support tls13
func NewServerHandshake(c net.Conn) (hs *ServerHandshake) {
	return &ServerHandshake{Conn: c, State: 1}
}

func HandshakeWithClient(c net.Conn) error {

	/*
		record := &Record{}
		if _, err := record.ReadFrom(c); err != nil {
			return err
		}

		fmt.Println("processClientHello2")
		clientHello, _ := ParseClientHelloMsg(record.Data)

		fmt.Println("debug TLSVersion:", clientHello.TLSVersion)
		fmt.Println("debug CipherSuite:", clientHello.CipherSuite)
		fmt.Println("debug Random:", clientHello.Random)
		fmt.Println("debug CompressionMethods:", clientHello.CompressionMethods)

		//reply ServerHello

		serverHello := &ServerHelloMsg{
			TLSVersion: VersionTLS12,
			SessionID:  clientHello.SessionID,
			Random: Random{
				Time: uint32(time.Now().Unix()),
				Data: [28]byte{0},
			},
			CipherSuite:       0xcca8,
			CompressionMethod: 0x00,
			Extensions:        []Extension{},
		}

		for _, ext := range clientHello.Extensions {

			if ext.Type() == ExtServerName || ext.Type() == ExtKeyShareType || ext.Type() == ExtSignatureAlgorithms || ext.Type() == ExtSupportedGroups {
				b, err := ext.Encode()
				if err == nil {
					ex, _ := NewExtension(ext.Type(), b)
					if ex != nil {
						serverHello.Extensions = append(serverHello.Extensions, ex)
					}
				}
			}

			if ext.Type() == ExtKeyShareType {
				//nSeverHello.Extensions = append(nSeverHello.Extensions, ext)
				b, _ := ext.Encode()
				fmt.Println("debug keyShare:", b)
			} else if ext.Type() == ExtServerName {
				//nSeverHello.Extensions = append(nSeverHello.Extensions, ext)
				b, _ := ext.Encode()
				fmt.Println("debug ServerName:", string(b))
			} else if ext.Type() == ExtSignatureAlgorithms {
				//nSeverHello.Extensions = append(nSeverHello.Extensions, ext)
				b, _ := ext.Encode()
				fmt.Println("debug SignatureAlgorithms:", b)
			} else if ext.Type() == ExtSupportedGroups {
				//nSeverHello.Extensions = append(nSeverHello.Extensions, ext)
				b, _ := ext.Encode()
				fmt.Println("debug SupportedGroups:", b)
			} else if ext.Type() == ExtSessionTicket {
				//nSeverHello.Extensions = append(nSeverHello.Extensions, ext)
				b, _ := ext.Encode()
				fmt.Println("debug SessionTicket:", b)
			} else if ext.Type() == ExtECPointFormats {
				//nSeverHello.Extensions = append(nSeverHello.Extensions, ext)
				b, _ := ext.Encode()
				fmt.Println("debug ECPointFormats:", b)
			} else if ext.Type() == ExtExtendedMasterSecret {
				b, _ := ext.Encode()
				fmt.Println("debug ExtendedMasterSecret:", b)
			} else if ext.Type() == ExtRenegotiationInfo {
				b, _ := ext.Encode()
				fmt.Println("debug RenegotiationInfo:", b)
			} else if ext.Type() == ExtEncryptThenMac {
				b, _ := ext.Encode()
				fmt.Println("debug EncryptThenMac:", b)

			} else {
				fmt.Println("debug ext", ext.Type)
			}
		}

	*/
	/*
		msgData := serverHello.ToBinary()
		msgDataLen := len(msgData)

		serverHelloRecord := &Record{
			RecordType: HandshakeRecord,
			TLSVersion: VersionTLS10,
			Length:     uint16(msgDataLen),
			Data:       msgData,
		}

		if _, err := serverHelloRecord.WriteTo(c); err != nil {
			fmt.Println("record write error:", err.Error())
			return err
		}
	*/
	fmt.Println("debug")

	record := &Record{}
	if _, err := record.ReadFrom(c); err != nil {
		return err
	}
	if record.RecordType != HandshakeRecord {
		return ErrHandShake
	}

	clientMsg, _ := ParseClientHelloMsg(record.Data)

	for _, ext := range clientMsg.Extensions {
		if ext.Type() == ExtSessionTicket {
			_, err := ext.Encode()
			if err != nil {
				return err
			}
			//c.rbuf.Write(b)
			break
		}
	}

	serverMsg := &ServerHelloMsg{
		TLSVersion:        VersionTLS12,
		SessionID:         clientMsg.SessionID,
		CipherSuite:       0xcca8,
		CompressionMethod: 0x00,
		Extensions: []Extension{
			&RenegotiationInfoExtension{},
			&ExtendedMasterSecretExtension{},
			&ECPointFormatsExtension{
				Formats: []uint8{0x00},
			},
		},
	}

	serverMsg.Random.Time = uint32(time.Now().Unix())
	rand.Read(serverMsg.Random.Data[:])
	b := serverMsg.ToBinary()

	record = &Record{
		RecordType: HandshakeRecord,
		TLSVersion: VersionTLS10,
		Length:     uint16(len(b)),
		Data:       b,
	}

	if _, err := record.WriteTo(c); err != nil {
		return err
	}

	record = &Record{
		RecordType: ChangeCipherRecord,
		TLSVersion: VersionTLS12,
		Length:     uint16(1),
		Data:       []byte{0x01},
	}
	if _, err := record.WriteTo(c); err != nil {
		return err
	}

	return nil
}
